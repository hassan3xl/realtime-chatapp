# Docker Guide for Your Chat App ðŸ³

Everything below is run from `chatapp/` â€” your project root.

---

## 1. The Big Picture

```mermaid
graph LR
    A["docker-compose.yml"] --> B["backend service<br/>(Python/Django)"]
    A --> C["frontend service<br/>(Node/Next.js)"]
    B --> D["Dockerfile<br/>backend/Dockerfile"]
    C --> E["Dockerfile<br/>frontend/Dockerfile"]
    D --> F["Image: python:3.11-slim"]
    E --> G["Image: node:18-alpine"]
```

| Concept | What it is |
|---------|-----------|
| **Image** | A snapshot/blueprint of your app â€” like a class |
| **Container** | A running instance of an image â€” like an object |
| **Dockerfile** | Recipe to build an image |
| **docker-compose.yml** | Orchestrates multiple containers together |
| **Volume** | Maps a folder on your machine into the container (live sync) |

---

## 2. Building

```bash
# Build both services
docker compose build

# Build just one service
docker compose build backend
docker compose build frontend

# Build from scratch (no cache)
docker compose build --no-cache
```

> [!TIP]
> Docker caches each step (`RUN`, `COPY`) as a **layer**. If [requirements.txt](file:///home/hasan/Documents/personal/chatapp/backend/requirements.txt) hasn't changed, `pip install` is skipped. That's why we `COPY requirements.txt .` *before* `COPY . .` â€” so code changes don't bust the pip cache.

---

## 3. Starting & Stopping

```bash
# Start everything (logs in foreground)
docker compose up

# Start in background (detached)
docker compose up -d

# Start just backend
docker compose up backend

# Stop everything
docker compose down

# Stop and remove volumes (clean slate)
docker compose down -v

# Restart a single service
docker compose restart backend
```

---

## 4. Interacting with Running Containers

This is the juicy part â€” how to **get inside** your containers and run commands.

### Open a shell (like SSH-ing into the container)

```bash
# Backend â€” opens a bash shell inside the Django container
docker compose exec backend bash

# Frontend â€” alpine uses sh, not bash
docker compose exec frontend sh
```

Once inside, you're in the container's filesystem at `/app/backend` or `/app/frontend`. You can run anything:

```bash
# Inside backend container:
python manage.py migrate
python manage.py createsuperuser
python manage.py shell
pip list

# Inside frontend container:
npm run build
npx next info
```

Type `exit` to leave.

### Run a one-off command (without opening a shell)

```bash
# Run Django migrations
docker compose exec backend python manage.py migrate

# Create a superuser
docker compose exec backend python manage.py createsuperuser

# Run Django shell
docker compose exec backend python manage.py shell

# Check installed packages
docker compose exec backend pip list

# Run npm commands on frontend
docker compose exec frontend npm list
docker compose exec frontend npx next info
```

### Run a command in a NEW container (not the running one)

```bash
# "run" creates a fresh container, "exec" uses the running one
docker compose run --rm backend python manage.py test
docker compose run --rm frontend npm test
```

> [!IMPORTANT]
> **`exec`** = runs in the **already running** container  
> **`run`** = spins up a **new** container, runs the command, then stops  
> Use `--rm` with `run` to auto-remove the container after it exits.

---

## 5. Viewing Logs

```bash
# All services
docker compose logs

# Follow logs (live stream)
docker compose logs -f

# Just backend logs
docker compose logs backend

# Last 50 lines of backend
docker compose logs --tail=50 backend

# Follow just frontend
docker compose logs -f frontend
```

---

## 6. Inspecting Containers

```bash
# See what's running
docker compose ps

# See resource usage (CPU, memory)
docker stats

# See details of a container
docker compose exec backend cat /etc/os-release

# Check which Python/Node version
docker compose exec backend python --version
docker compose exec frontend node --version
```

---

## 7. How Your docker-compose.yml Works

```yaml
services:
  backend:
    build: ./backend              # Build from backend/Dockerfile
    ports:
      - "8000:8000"               # host:container â€” maps port
    volumes:
      - ./backend:/app/backend    # Live-sync your code into container
    environment:
      - DJANGO_SETTINGS_MODULE=settings.dev
    command: python manage.py runserver 0.0.0.0:8000  # Overrides Dockerfile CMD
```

| Key | What it does |
|-----|-------------|
| `build` | Path to the Dockerfile |
| `ports` | `"HOST:CONTAINER"` â€” expose container port to your machine |
| `volumes` | `"./local/path:/container/path"` â€” live code sync |
| `environment` | Set env vars inside the container |
| `command` | Override the default CMD from the Dockerfile |
| `depends_on` | Start this service after the listed ones |
| `env_file` | Load env vars from a file |

> [!NOTE]
> **Volumes** are why you can edit code on your machine and see changes in the container immediately â€” the files are shared, not copied.

---

## 8. How a Dockerfile Works (Your Backend)

```dockerfile
FROM python:3.11-slim          # 1. Start from a base image

WORKDIR /app/backend           # 2. Set working directory

ENV PYTHONUNBUFFERED=1         # 3. Set environment variables

RUN apt-get update && ...      # 4. Install system-level deps

RUN pip install --upgrade pip  # 5. Upgrade pip

COPY requirements.txt .        # 6. Copy just requirements first
RUN pip install -r req...      # 7. Install Python deps (cached layer!)

COPY . .                       # 8. Copy all code

EXPOSE 8000                    # 9. Document the port (metadata only)

CMD ["python", "manage.py"...] # 10. Default command when container starts
```

> [!TIP]
> **Layer caching order matters!** Put things that change **rarely** (system deps, pip install) **before** things that change **often** (your code). This way Docker reuses cached layers and builds are fast.

---

## 9. Common Workflows

### "I added a new Python package"
```bash
# 1. Add to requirements.txt
# 2. Rebuild
docker compose build backend
# 3. Restart
docker compose up -d backend
```

### "I added a new npm package"
```bash
# Option A: exec into running container
docker compose exec frontend npm install some-package

# Option B: rebuild
docker compose build frontend && docker compose up -d frontend
```

### "I want to reset everything"
```bash
docker compose down -v          # Stop + remove volumes
docker compose build --no-cache # Fresh build
docker compose up -d            # Start fresh
```

### "Something is broken, let me debug"
```bash
docker compose logs -f backend  # Check logs
docker compose exec backend bash  # Get inside and poke around
```

---

## 10. Cheat Sheet

| Command | What it does |
|---------|-------------|
| `docker compose up -d` | Start all services in background |
| `docker compose down` | Stop all services |
| `docker compose build` | Build/rebuild images |
| `docker compose logs -f` | Stream live logs |
| `docker compose exec backend bash` | Shell into backend |
| `docker compose exec frontend sh` | Shell into frontend |
| `docker compose ps` | List running containers |
| `docker compose restart backend` | Restart one service |
| `docker compose run --rm backend python manage.py test` | One-off command |
| `docker system prune -a` | âš ï¸ Clean ALL unused images/containers |

> [!CAUTION]
> `docker system prune -a` removes **all** unused images, not just this project's. Use carefully â€” you'll have to rebuild everything.
